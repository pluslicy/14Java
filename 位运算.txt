1. 表示方法：
    在Java语言中，二进制数使用补码表示，最高位为符号位，整数的符号位为0，负数为1.
	十进制  7	    -7
	原码 0000 0111	1000 0111
	反码 0000 0111  1111 1000
	补码 0000 0111	1111 1001
    1) 正数 
        原码，反码，补码相同
    2) 负数
        原码：二进制
	反码：原码基础上，符号位不变，其余各个位取反
	补码：反码+1
    运算法则：
        减去一个正数等于加上一个负数
	1-1 = 1+(-1) = 0

	如果使用原码表示一个数：
	  [0000 0001]原码 + [1000 0001]原码 = [1000 0010]原码 = -2 
	  计算错误。
	如果使用反码表示一个数：
	  [0000 0001]反码 + [1111 1110]反码 = [1111 1111]反码 = [1000 0000]原码 = -0 
	  +0和-0 表示的含义一样
	如果使用补码表示一个数：
	  [0000 0001]补码 + [1111 1111]补码 = [0000 0000]补码 = [0000 0000]原码 = 0

	注意：
	  -1 - 127
	  = [1000 0001]原码 + [1111 1111]原码
	  = [1111 1111]补码 + [1000 0001]补码
	  = [1000 0000]补码
	  = -128

	-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.

    
    同余概念：
	两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余
	记作 a ≡ b (mod m)

	两个整数 a,b若它们除以整数m的余数相同，则称a,b对于模m同余。
	  4  mod 12 = 4;
	  16 mod 12 = 4;
	  28 mod 12 = 4;
	4,16,28关于摸12同余
	  -2 mod 12 = 12 - 2 = 10
	  -4 mod 12 = 12 - 4 = 8
	  8  mod 12 = 8
	-4与8关于12 同余
	
	10 (mod 12) = 10
	-2 (mod 12) = 10
	 7 -2 ≡ 7 + 10 (mod 12) 

	使用正数替代负数：
	  定理1 ： a ≡ a (mod m)
	  定理2 ：(定理证明：http://baike.baidu.com/view/79282.htm)
		如果a ≡ b (mod m)，c ≡ d (mod m) 那么:
		(1)a ± c ≡ b ± d (mod m)
		(2)a * c ≡ b * d (mod m)
	所以：
		7 ≡ 7 (mod 12)
		(-2) ≡ 10 (mod 12)
		7 -2 ≡ 7 + 10 (mod 12)

	例如：
	   2-1 = 2+(-1)
	   = [0000 0010]原 + [1000 0001]原
	   = [0000 0010]反 + [1111 1110]反
	   先到这一步, -1的反码表示是1111 1110. 如果这里将[1111 1110]认为是原码, 则[1111 1110]原 = -126, 这里将符号位除去, 即认为是126.
	   发现有如下规律:
		(-1) mod 127 = 126
		126 mod 127 = 126
	   即:
		(-1) ≡ 126 (mod 127)
		2-1 ≡ 2+126 (mod 127)
	   2-1 与 2+126的余数结果是相同的! 而这个余数, 正式我们的期望的计算结果: 2-1=1
	   所以说一个数的反码, 实际上是这个数对于一个膜的同余数. 而这个膜并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值!既然反码可以将减法变成加法, 那么现在计算机使用的补码呢? 为什么在反码的基础上加1, 还能得到正确的结果?其实, 在反码的基础上+1, 只是相当于增加了膜的值
	   2-1= 2+(-1)
	   = [0000 0010]原 + [1000 0001]原
	   = [0000 0010]补 + [1111 1111]补
	   如果把[1111 1111]当成原码, 去除符号位, 则:[0111 1111]原 = 127,其实, 在反码的基础上+1, 只是相当于增加了膜的值:
		(-1) mod 128 = 127
		127 mod 128 = 127
		2-1 ≡ 2+127 (mod 128)
	   此时, 表盘相当于每128个刻度转一轮. 所以用补码表示的运算结果最小值和最大值应该是[-128, 128].但是由于0的特殊情况, 没有办法表示128, 所以补码的取值范围是[-128, 127]

2. 位移运算
    1) 左位移运算符	<< 
	5	//  0000 0101 
	5<<3	//  0010 1000 = 2,5 + 2,3 = 32+8 = 40

    2) 有符号右移运算符	>>
	当操作数为正数，高位插入0。
	当操作数为负数，高位插入1。
	5	//0000 0101 
	5>>1	//0000 0010 = 2
	-5>>1	//1111 1011 -> 1111 1101 -> 1111 1100 -> 1000 0011 = -3
    3) 无符号右移运算符	>>>
	无论操作数为正数还是负数，高位插入0
	-5>>1	//11111111 11111111 11111111 11111011 -> 01111111 11111111 11111111 11111111  1101
		
    4) 注意:
	如果对char,byte,short进行位移处理时，先将其转换成一个int.
	如果对long进行位移处理时，得到的结果也是long
	右移一位相当于除以2，左移一位（不溢出）相对于乘以2；移位运算速度高于乘除运算
	如果进行位逻辑运算的两个操作数的数据长度不相同，则返回值应该是数据长度较长的数据类型
	按位异或(^)可以不使用临时变量交换两个值，也可以使某个整型数的特定位的值翻转
	    1) 值交换
		int a = 3;
		int b = 4
		a = a ^ b;
		b = b ^ a;
		a = a ^ b;
	    2) 特定位翻转
		int a = 3;   // 0000 0011
		//翻转 第2位 0000 0010
		int b = a ^ 2;
	按位与运算可以用来屏蔽特定的位，也可以用来取某个整型数中特定的位

 
3. 位异或运算
    两个操作数的位中，相同则结果为0，不同则结果为1。如果两个操作数的精度不同，结果的精度与精度高的操作数相同
	 0异或任何数 = 任何数
		0 ^ 0 = 0;
		0 ^ 1 = 1;
	  1异或任何数 = 任何数取反
		1 ^ 0 = 1;
		1 ^ 1 = 0;
4. 位与运算
    两个操作数对应位执行布尔代数，两个位都为1时输出1，否则0。如果两个操作数的精度不同，结果的精度与精度高的操作数相同
		int a = 7;  // 0000 0111
		int b = 4;  // 0000 0100
		int result = a & b ; // 0000 0100
5. 位或运算
    两个操作数对应位执行布尔代数，两个位都为0时输处0，否则1。如果两个操作数的精度不同，结果的精度与精度高的操作数相同
		int a = 7;
		int b = 4;
		int result = a | b; // 0000 0111
6. 按位取反
    将操作数中的0改为1,1改为0
		int a = 7; // 00000000 00000000 00000000 00000111
		int b = ~a;// 11111111 11111111 11111111 11111000

